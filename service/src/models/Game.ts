import { Question } from './Question';
import * as uuid from 'uuid';
import { attribute, table, autoGeneratedHashKey } from '@aws/dynamodb-data-mapper-annotations';
import { AppErrorCode } from './AppError';

let tableName = process.env.AWS_DYNAMODB_TABLE_NAME;
if (tableName === undefined) {
    tableName = 'betQ_games';
}

@table(tableName)
export class Game {

    @autoGeneratedHashKey()
    id: string;

    @attribute()
    lastUpdated: string;

    @attribute()
    currentQuestion: Question;

    @attribute()
    questionNumber: number;

    @attribute()
    totalQuestions: number;

    @attribute()
    score: number;

    @attribute()
    atRisk: number;

    @attribute()
    status: GameStatus;

    setupNewGame() {
        this.id = uuid.v4();
        this.totalQuestions = parseInt(process.env.DEFAULT_NUMBER_OF_QUESTIONS === undefined ? '12' : process.env.DEFAULT_NUMBER_OF_QUESTIONS
        , 10);
        this.questionNumber = 0;
        this.score = 1000;
        this.atRisk = 0;
        this.status = GameStatus.Start;
    }

    hasCurrentQuestion(): boolean {
        return this.currentQuestion !== undefined;
    }

    getCategoryResponse() {
        return {
            'questionNumber': this.questionNumber,
            'category': this.currentQuestion.category
        };
    }

    setNextQuestion(question: Question) {
        this.currentQuestion = question;
        this.questionNumber++;
    }

    validateGameStatus(requiredState: GameStatus[]): boolean {
        for (let i = 0; i < requiredState.length; i++) {
            if (this.status === requiredState[i]) {
                return true;
            }
        }
        return false;
    }

    private validateBet(betAmount: number): boolean {
        if (betAmount < this.getMinimumBet() || betAmount > this.getMaximumBet()) {
            return false;
        } else {
            return true;
        }
    }

    setBet(betAmount: number): boolean {
        if (this.validateBet(betAmount)) {
            this.score = this.score - betAmount;
            this.atRisk = betAmount;
            return true;
        } else {
            return false;
        }
    }

    processCorrectAnswer(selectedAnswerId: string) {
        const winnings = this.atRisk * 2;
        this.score = this.score + winnings;
        return {
            'result': 'CORRECT',
            'correctAnswer': this.currentQuestion.correctAnswerId,
            'winnings': winnings,
            'totalScore': this.score
        };
    }

    processIncorrectAnswer(selectedAnswerId: string) {
        const lostScore = this.atRisk;
        this.atRisk = 0;
        return {
            'result': 'INCORRECT',
            'correctAnswer': this.currentQuestion.correctAnswerId,
            'lost': lostScore,
            'totalScore': this.score
        };
    }

    getMinimumBet(): number {
        return Math.ceil(this.score * 0.25);
    }

    getMaximumBet(): number {
        return this.score;
    }

    isGameEnd(): GameEndScenario {
        if (this.score === 0) {
            return GameEndScenario.Bankrupt;
        } else if (this.totalQuestions === this.questionNumber) {
            return GameEndScenario.Completed;
        } else {
            return GameEndScenario.None;
        }
    }
}

export enum GameStatus {
    Start = 'START',
    Category = 'CATEGORY',
    Question = 'QUESTION',
    Answered = 'ANSWERED',
    Bankrupt = 'BANKRUPT',
    End = 'END'
}

export enum GameEndScenario {
    None = 'NONE',
    Bankrupt = 'BANKRUPT',
    Completed = 'COMPLETED'
}